\documentclass[a4paper,hidelinks,12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath,graphicx}
\usepackage{indentfirst}
\usepackage{colortbl}
\usepackage{setspace}
\usepackage{float}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tabularx}
\usepackage{pdfpages}
\usepackage{array}      % для настройки столбцов
\usepackage{booktabs}   % для красивых линий
\usepackage{multirow}
\usepackage{makecell}   % для \makecell
\usepackage{graphicx}
\usepackage{adjustbox}
\RequirePackage{booktabs}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.5,0.5}
\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}


\usepackage[left=3cm,right=1.5cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\setcounter{secnumdepth}{4}
\linespread{1.5}
\usepackage{xcolor}

\newenvironment{alphasection}{%
	\ifnum\alphainsection=1%
	\errhelp={Let other blocks end at the beginning of the next block.}
	\errmessage{Nested Alpha section not allowed}
	\fi%
	\setcounter{alphasect}{0}
	\def\alphainsection{1}
}{%
	\setcounter{alphasect}{0}
	\def\alphainsection{0}
}%

% \begin{document}
% \fixmargins
% \makepreliminarypages

% \oneandhalfspace

% \tableofcontents

% \include{Chapter0} % Введение
% \include{Chapter1} % Постановка задачи
% \include{Chapter2} % Обзор существующих решений
% \include{Chapter3} % Исследование и построение решения задачи
% \include{Chapter4} % Описание Экспериментальной части
% \include{Chapter5} % Заключение

% \nocite{*}
% \bibliographystyle{gost71u} % Для соответствия требованиям об оформлении списка литературы
% \bibliography{references}

% % \include{Appendix} 

% \end{document}

\begin {document}
\begin {titlepage}
\thispagestyle{empty}

\begin{center}
	\vspace{-1cm}
	
	
	%
	% No necessity to specify laboratory.
	%
	\includegraphics[width=0.5\textwidth]{gzlogo.png}\\
	Московский Государственный Университет им. М.В. Ломоносова\\
	Факультет Вычислительной Математики и Кибернетики\\
	Кафедра Интеллектуальных Информационных Технологий\\
	
	\vspace{3cm}
	
	{\Large Никитин Сергей Денисович}
	
	\vspace{1cm}
	
	{\LARGE\bfseries Сравнительный анализ представлений функций дистанции со знаком\\}
	
	\vspace{1cm}
	
	{ ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}
\end{center}

\vfill

\begin{flushright}
	\textbf {Научный руководитель:}\\
	к.ф.-м.н.\\
	В.А.Фролов\\
	\vspace{10mm}
\end{flushright}

\vfill

\begin{center}
	Москва, 2025
\end{center}

\end{titlepage}

\setcounter{page}{2}
\onehalfspacing

\begin{abstract}
	Дипломная работа посвящена сравнительному анализу функций дистанции со знаком (SDF) в 
	задачах рендеринга 3D-моделей. Целью исследования является разработка и реализация бенчмарка для оценки различных 
	представлений SDF по метрикам качества изображения (PSNR), времени рендеринга и размера модели. В работе 
	рассмотрены теоретические основы SDF, включая аналитические, воксельные и нейронные представления, а также 
	проведён обзор существующих подходов и их ограничений. Разработанный бенчмарк позволяет рендерить 3D-модели в 
	различных представлениях и сравнивать их производительность на единой платформе. Эксперименты проведены на наборе
	 тестовых моделей с использованием современного оборудования и программных инструментов. Работа имеет практическую значимость для компьютерной графики, игровой индустрии и 3D-моделирования.
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Введение}
\subsection{Актуальность}

В современном мире комьютерная графика используется для решения широкого класса задач. Зародившись, как развлечение для небольшого числа людей, на текущий момент она породила целые индустрии, в который работают тысячи людей по всему миру.
С каждым годом проработанность виртуальных миров возрастает, что в свою очередь требует увеличение вычилительных мощностей для рендера таких сцен и ресурсов для хранения полученных результатов.

В компьютерной графике существует множество представлений объектов. Однако самый популярный - полигональная сетка (меш), потому что 
с помощью неё можно сколь угодно точно задать поверхность. Чем сложнее поверхность, тем больше треугольников будет создано для поддержания заданной детализованности. Значит, возрастут затраты на память и рендер таких объектов.

\par
Другим популярным представлением объектов можно назвать функцию расстояния со знаком (SDF). Функции дистанции со знаком 
(Signed Distance Functions, SDF) играют ключевую роль в современных задачах компьютерной графики, 3D-моделирования, рендеринга и 
физического моделирования. Они обеспечивают компактное и гибкое представление геометрических объектов, позволяя эффективно выполнять 
операции рендеринга, столкновений и оптимизации. Разнообразие подходов к реализации SDF, таких как аналитические, воксельные и 
нейронные представления, создаёт необходимость их сравнительного анализа для выбора оптимального решения в конкретных задачах. 
\par
SDF характеризуются рядом фундаментальных свойств, определяющих их практическую ценность в задачах компьютерной графики. 
Ключевым атрибутом является инвариантность относительно масштабирования и аффинных преобразований, что позволяет эффективно 
манипулировать геометрическими объектами без потери точности представления. Более того, SDF обладают свойством композиционности, 
что обеспечивает возможность построения сложных геометрических форм посредством математических операций над базовыми примитивами. Актуальность данной темы обусловлена растущим спросом на высококачественный и производительный рендеринг в игровой индустрии, 
виртуальной реальности и автоматизированном проектировании, где SDF находят широкое применение. 
\par 
В данной работе решается актуальная задача приведения нескольких методов к формату, в котором их можно сравнить по нескольким метрикам и тем самым получить
данные о плюсах и минусах рассматриваемых реализаций.

\newpage
\subsection{Цель работы}
Цель: разработка бенчмарка для сравнительного анализа различных представлений функций дистанции со 
знаком по метрикам качества рендеринга (PSNR), времени рендеринга и размера модели, а также в выявлении их преимуществ и недостатков.

\begin{enumerate}
	\item Изучить теоретические основы и существующие подходы к функциям дистанции со знаком. 
	\item Выбрать метрики и датасеты, которые будут максимально отражать требования к рассматриваемым методам.
	\item Разработать программный бенчмарк для рендеринга 3D-моделей в различных представлениях SDF. 
	\item Провести экспериментальное сравнение представлений, проанализировать результаты и сформулировать рекомендации по выбору оптимальных представлений SDF.
	\item Оформить полученный бенчмарк в виде докер контейнера для более простого и интуитивного запуска из "коробки".
\end{enumerate}

\subsection{Формальная постановка задачи}

Вход:
\par
\begin{enumerate}
	\item Конфигурационный файл:
	\begin{enumerate}
		\item models $\in \mathbb{R}^{N_1 \times N_2}$ - пути до моделей, которые будут рендерится каждым выбранным методом. Всего моделей $N_1$ штук.
		\item backends $\in \mathbb{R}^{N_3}$ - выбор бэкендов для рендера, это может быть CPU, GPU. $N_3$ - количество бэкендов.
		\item renderers $\in \mathbb{R}^{N_4}$ - есть возможность использовать трассировку пути и обычный рендер.
		\item render\_modes $\in \mathbb{R}^{N_5}$ - массив чисел, каждое из которых представляет то, как будет рендерится каждый объект.
		\item $w, \ h \in \mathbb{R}$ - разрешение, в котором рисуется изображение сцены.
		\item cameras $\in \mathbb{R}$ - количество ракурсов.
		\item spp $\in \mathbb{R}$ - количество лучей, пускаемых в каждый пиксель.
		\item iters $\in \mathbb{R}$ - сколько раз надо отрендерить каждый ракурс для усреднения результатов.
		\item output\_folder $\in \mathbb{R}^{N_6}$ - путь до папки, куда будут сохраняться все результаты.
		\item repr\_configs $\in \mathbb{R}^{\sum_{i=0}^{M} K_i \cdot B_i}$ - параметры для каждого метода, $M$ - количество рассматриваемых методов,
		$K_i$ - количество вариантов метода $i$, $B_i$ - параметры для метода $i$.
	\end{enumerate}
	\item slicer $\in \mathbb{R}^{N_7}$- путь до Kernel Slicer.
\end{enumerate}

Выход:
\par
\begin{enumerate}
	\item build $\in \mathbb{R}^{M \times N_1 \times N_3 \times N_4 \times N_5 \times N_6}$ - папка, куда сохраняются все представления выбранных методов для каждой модели.
	\item metrics - папка, содержащая полученные данные
	\begin{enumerate}
		\item build\_phase $\in \mathbb{R}^{3 \times M \times N_1 \times N_3 \times N_4 \times N_5 \times N_6}$ - .csv файл, содержащий информацию о времени построения каждого 
		метода для конкретных моделей. Например, время построения, полученный и оригинальный размер.
		\item render\_phase $\in \mathbb{R}^{8 \times M \times N_1 \times N_3 \times N_4 \times N_5 \times N_6}$ - .csv файл, куда записываются такие вещи, как время рендера, размер модели, метрики качества.
	\end{enumerate} 
	\item images $\in \mathbb{R}^{w \times h \times cameras \times M \times N_1 \times N_3 \times N_4 \times N_5 \times N_6}$ - папка с отрендеренными изображениями.
\end{enumerate}

\newpage

\section{Обзор существующих работ}

Несмотря на то, что существует множество методов сжатия 3D-геометрии, разработка метода сжатия или представления 
поверхности, который можно было бы использовать непосредственно во время рендеринга, остается серьезной проблемой. 
Это связано с фундаментальным компромиссом между достижением высокой степени сжатия, качеством и вычислительной сложностью 
метода декомпрессии, который может быть трудно распараллелить [Barczak et al. 2024; Kuth et al. 2024; Mlakar et al. 2024; Николаев и др. 2022]. 
Другой проблемой являются уровни детализации (LoD), которые обычно увеличивают потребление памяти, поскольку они хранятся в виде отдельных 
структур данных и также могут создавать артефакты [Haydel et al., 2023; Lloyd et al., 2020; Maggiordomo et al., 2023]. 

Отдельно стоит отметить выбор метода рендеринга, который так или иначе будет использоваться на протяжении всех работ. 
Это выбор между растеризацией и трассировкой лучей. В данном исследовании уделяется больше внимания методам, основанным 
на трассировке лучей, и на это есть три причины.

\begin{enumerate}
	\item Обычно алгоритмическая сложность рендеринга с растеризацией линейно зависит от количества 
	полигонов (либо геометрических примитивов), в то время как при трассировке лучей она линейно зависит 
	от количества пикселей изображения и логарифмически зависит от количества полигонов. Существующие 
	нестандартные методы рендеринга используют трассировку лучей или пирамид для определения видимости [Xue 2016].
	\item Вторая причина - универсальность трассировки лучей, которая позволяет визуализировать примитивы любого 
	вида путем алгоритмического определения пересечения луча и примитива: т.е. не требует обязательной тесселяции в 
	треугольники.
	\item Наконец, третья причина - это возможность рендеринга как на центральном, так и 
	на графическом процессорах, даже одновременно, если это необходимо. Это важно для научной 
	визуализации и для рендеринга CAE-данных, поскольку позволяет работать с огромными объемами данных 
	в оперативной памяти. Например, это активно используют визуализаторы на базе OSPRay [Wald et al., 2017], 
	а в индустрии кинопроизводства MoonRay [Lee et al., 2017]. [2017] использует этот путь из-за высокой гибкости 
	рендерера на базе центрального процессора.
\end{enumerate}

\newpage

\subsection{Представления на основе полигональной сетки}

Стандартный подход с использованием уровня детализации (LoD) [Chen et al., 2023; Garland and Heckbert, 1997] не позволяет достичь двух важнейших целей. 

Во-первых, он не обеспечивает компактного хранения геометрии, поскольку каждый уровень детализации постепенно увеличивает потребление памяти. Во-вторых, он по своей сути не поддерживает плавные переходы с высоким уровнем детализации и потоковую передачу. В то же время алгоритмы сжатия сетки часто создают представления, которые трудно визуализировать, особенно при трассировке лучей [Maglo et al., 2015]. 

Геометрические изображения [Gu et al., 2002] представляют собой метод преобразования произвольной поверхности в полностью правильную структуру. Это позволяет легко создавать новые сетки и обрабатывать геометрию как изображение, которое может быть дополнительно сжато [Edavamadathil Sivaram и др., 2024; Peyré and Mallat, 2005] и с трассировкой лучей [Carret al., 2006], обеспечивая при этом как динамическую геометрию, так и эффективный уровень детализации схемы без дополнительных затрат. Создание геометрического изображения требует хорошей параметризации 3D-поверхности, которую не всегда легко получить. 

Micromesh [Maggiordomo et al., 2023] преобразует сетку с большим количеством полигонов в “базовую” сетку с низким количеством полигонов вместе со смещением. Векторы смещений сохраняются для каждой вершины в расчлененной (базовой) сетке, а карта смещений используется внутри полигона. В некотором смысле, этот подход можно рассматривать как эволюцию геометрических изображений, адаптированных к конкретным требованиям к качеству и оптимизированных для современного графического оборудования. 

Концепция дерева тесселяции, представленная в [Haydel et al., 2023], направлена на сокращение передачи данных из памяти в блоки обработки при растеризации и трассировке лучей треугольных сеток. Это исследование подчеркивает важность уровней детализации для повышения производительности трассировки лучей и энергоэффективности. Однако оно не решает проблему компактного хранения геометрических данных. Вполне вероятно, что подход [Haydel et al., 2023] принят Nvidia в расширении Vulkan под названием VK\_NV\_cluster\_acceleration\_structure [VK\_NV\_TC, 2025].

Представления на основе сетки были и остаются современным подходом (SOTA) к рендерингу в компьютерной графике. 
Это подтверждается недавними демонстрациями от Nvidia: [RTXMG 2025; VK\_NV\_TC\ 2025; VK\_NV\_LC\ 2025]. 
Ключевым аспектом здесь является то, что как методы тесселяции [VK\_NV\_TC\ 2025], так и методы определения уровня детализации
 (LOD) [VK\_NV\_LC\ 2025] совместимы как с растеризацией, так и с трассировкой лучей. Учитывая, что производители 
 графических процессоров внедряют аппаратное ускорение для этих методов, мы ожидаем, что наиболее эффективная реализация 
 будет включать использование соответствующих функций расширения Vulkan, которые напрямую поддерживаются драйвером графического 
 процессора. Таким образом, программная архитектура бенчмарка сохраняет возможность обработки сеток с помощью трассировки лучей с возможностью интеграции таких подходов при необходимости. 

\subsection{Неявные аналитические представления}

Набор разреженных блоков (SBS) [Herman et al., 2022] объединяет BVH с небольшими регулярными сетками 
внутри его листьев, называемыми блоками. В нем используются эффективные алгоритмы пересечения 
(аналитический метод и метод Ньютона) для поиска пересечений лучей и SDF. Эти алгоритмы запрашивают значения SDF 
в углах вокселя, которые должны явно поддерживаться структурой данных. VDB [Museth 2013] использует иерархические 
многоуровневые сетки (своего рода B + дерево в трехмерном пространстве), что помогает поддерживать баланс высот при построении и 
обходе. VDB использует битовую маску, которая хранит информацию о том, какие вокселы имеют значение; они называются “активными вокселами”. 
Однако VDB не поддерживает значения самой функции SDF, и в то же время иерархические сетки обычно демонстрируют низкую 
производительность рендеринга. Оптимизированная графическая реализация преобразования лучей с помощью структур 
VDB представлена в [Hoetzlein 2016], где луч пересекает объем узла с помощью дифференциального 3D-анализатора (3DDA).

Октодерево разреженных вокселей (SVO) [Laine and Karras, 2010] включает структуру, которая хранит только 
занятые области; большая часть воксельной информации хранится на родительском уровне, чтобы уменьшить 
использование памяти. Другим применением SVO является работа [Pujol and Chica 2024], в которой представлено исходное 
октадерево с добавлением того, что коэффициенты многочлена сохраняются в листьях, если они имеют часть поверхности; 
в противном случае, на этапе предварительной обработки [Pujol and Chica 2024] пытается максимизировать размер из поля, 
обозначающего пустую область. Это усовершенствование позволяет хранить данные, расположенные только на границе объекта. 
На следующем этапе [Pujol and Chica 2024] использует полиномы для интерполяции значений SDF путем нахождения аналитического 
пересечения. Подход Пуйоля и Чики позволяет использовать различные типы интерполяции, но он также накладывает ограничения 
и проблемы, связанные с аналитическим поиском корней. Алгоритм построения SDF основан на их предыдущей работе [Pujol и Chica 2023], 
в которой представлен подход к эффективному представлению SDF и запросам к ним путем построения адаптивной структуры данных. 
Он использует RMSE для принятия решения о разделении узлов. [Pujol and Chica, 2023] могут использовать несколько 
методов интерполяции, таких как трикубический, для решения линейной системы [Boateng and Bradach, 2023], 
которая требует больших вычислительных затрат.

Хэш-таблицы [Nießner et al., 2013] обычно используются вместо октодерева в приложениях 
реконструкции, где геометрия постоянно меняется и важно быстро обновлять структуру данных.

Методы рендеринга на основе SDF обладают несколькими ключевыми преимуществами:
\begin{enumerate}
	\item Унифицированные структуры данных: Одни и те же представления данных могут использоваться как для поверхностного, так и для объемного рендеринга.
	\item Простота генерации уровня детализации (LOD) и переключения во время рендеринга: Лоды могут быть получены простым способом, по крайней мере, для "водонепроницаемых" объектов.
\end{enumerate}

\subsection{Рендеринг геометрии CSG}

В моделях CAD геометрия может быть определена с помощью так называемого представления Constructive Solid Geometry (CSG). 
Это представление описывает геометрию как набор базовых примитивов (таких как сфера, цилиндр, конус и другие) и 
операции, выполняемые над этими примитивами, как над наборами. Основным преимуществом такого представления является 
его точность, как правило, высокая гибкость и чрезвычайная компактность (например, MPR CSG [Keeter 2020]). 
Основным недостатком является его высокая вычислительная сложность из-за потенциального значительного совпадения между 
примитивами в некоторых моделях, что вынуждает алгоритм рендеринга интенсивно перебирать поддеревья CSG. Чтобы эффективно 
отобразить такое представление, необходимо преобразовать древовидную иерархию CSG, минимизируя взаимные совпадения, когда это возможно [Bogolepov 2016]. 
Один из таких подходов называется “Повторное плетение” [Benthin et al., 2017], который уменьшает количество перекрывающихся элементов 
внутри объема листа. Однако недостатком ребрендинга является увеличение объема памяти и усложнение процедуры сборки.

MPR использует “ленту” для эффективного хранения данных и передачи их в графический процессор. Этот подход 
обеспечивает эффективную производительность и сжатие модели, состоящей из операций с множествами и самими типами множеств. 
Кроме того, метод предоставляет возможности для создания новых множеств с помощью пользовательских команд. 
С другой стороны, в отличие от формата SDF, этот формат специализируется только на обработке CSG, 
а не на чем-то общем. Еще одним недостатком является то, что программная реализация MPR может обрабатывать небольшое количество фигур. 
Поэтому сложно визуализировать что-то большое и с большим количеством деталей.

Визуализация геометрии CSG остается интересным направлением для будущих исследований и разработок. 
Наиболее многообещающие результаты можно увидеть в [Bogolepov 2016]. Объединив идеи [Bogolepov, 2016]; Бентин и др., 2017] и [Китер, 2020], можно было бы разработать передовую технологию.

\newpage

\section{Исследование и построение решения задачи}

\subsection{Выбор метрик}

В рамках исследования методов представления функций дистанции со знаком (SDF) критически 
важным этапом является выбор метрик, позволяющих объективно оценить компромисс между качеством 
реконструкции, производительностью и эффективностью сжатия. Предлагаемый набор метрик - PSNR, 
размер модели и время рендеринга - формирует комплексную систему оценки, учитывающую ключевые 
требования задач компьютерной графики: точность воспроизведения геометрии, возможность работы в 
реальном времени и компактность представления данных.

\begin{enumerate}
	\item \textbf{Пиковое отношение сигнала к шуму (PSNR)}
	\par
	PSNR служит количественной мерой точности реконструкции поверхности относительно эталонного меша. Для SDF, 
	задающих расстояние до поверхности со знаком, PSNR вычисляется через среднеквадратичную ошибку (MSE) между 
	эталонными и восстановленными значениями расстояний:
	$$
	\text{MSE} = \frac{1}{N} \sum_{i=1}^{N} (d_{\text{ref}}^{(i)} - d_{\text{pred}}^{(i)})^2
	$$

	$$
	\text{PSNR} = 10 \cdot \log_{10}\left(\frac{\text{MAX}^2}{\text{MSE}}\right)
	$$

	где $ MAX $ - максимальное расстояние в сцене, $ N $ - количество пробных точек. Для 8-битных данных 
	$ MAX = 255 $, но в 3D-контексте значение определяется масштабом сцены. Высокий PSNR (>30 дБ) 
	указывает на близость восстановленной геометрии к эталону, что критично для приложений, требующих точного 
	воспроизведения деталей (медицинская визуализация, инженерное моделирование).
	
	Ограничение PSNR - слабая корреляция с субъективным восприятием качества при наличии структурных искажений. 
	Однако для задач, где приоритетом является метрическая точность (напр., CAD-модели), PSNR остаётся эталонным инструментом.

	\item \textbf{Размер модели}
	\par
	Эффективность сжатия оценивается через объём памяти, требуемый для хранения параметров представления. 
	Для нейросетевых методов типа DeepSDF (ссылка на статью) размер определяется числом параметров сети. Традиционные SDF в воксельном представлении требуют 
	$ O(n^3) $ памяти.

	Сравнение коэффициентов сжатия $ C = \frac{V_{raw}}{V_{compressed}} $ позволяет оценить выигрыш от использования компактных 
	представлений.

	\item \textbf{Время рендеринга}
	\par
	Производительность рендеринга измеряется временем генерации кадра при использовании:
	\begin{itemize}
		\item \textbf{Ray marching} с шагом $\Delta t$:
		$$
		t_{\text{total}} = N_{\text{rays}} \cdot \left(\frac{t_{\text{max}} - t_{\text{min}}}{\Delta t}\right) \cdot t_{\text{SDF}}
		$$

		где $ t_{SDF} $ - время вычисления SDF в точке.
		\item \textbf{Ray tracing} (аналитический поиск персечения):
		$$
		t_{\text{total}} = N_{rays} \cdot \left(w \cdot h + \log{N_{triangles}}\right) 
		$$

		где $w, h$ - размеры изображения.
	\end{itemize}

	Нейросетевые SDF (напр., DeepSDF) увеличивают $ t_{SDF} $ из-за вычислений прямого распространения, 
	но компенсируют это сокращением $ n $ благодаря непрерывности представления. 

	Оптимизации типа иерархических структур ускорения или кэширования значений SDF критичны для достижения частоты кадров >30 FPS.

	\item \textbf{Синтез требований}
	\par
	Выбранные метрики образуют треугольник компромиссов:
	\begin{itemize}
		\item PSNR $\Leftrightarrow $ Размер модели: Повышение точности (PSNR) через увеличение разрешения или сложности модели ведёт к росту объёма данных.
		\item PSNR $\Leftrightarrow $ Время рендеринга: Точные SDF с высокой детализацией требуют больше вычислений на луч.
		\item Размер модели $\Leftrightarrow $ Время рендеринга: Сжатые представления (напр., нейросетевые) уменьшают объём данных, но могут замедлять рендеринг из-за вычислений параметров.
	\end{itemize}
\end{enumerate}

\par
Предложенный набор метрик позволяет количественно оценить применимость методов SDF для задач, требующих баланса между точностью, производительностью и эффективностью использования ресурсов. Дальнейшие исследования могут дополнить систему оценкой структурного сходства (SSIM) и субъективным тестированием, но текущий выбор оптимален для инженерного анализа.

\newpage

\subsection{Выбор датасета}

Для всесторонней оценки методов представления функций дистанции со знаком (SDF) разработана двухуровневая система 
тестирования, использующая комплементарные датасеты. Такой подход позволяет анализировать как базовую эффективность 
методов в штатных условиях, так и их устойчивость к экстремальным нагрузкам, что критично для валидации промышленных решений.

Эти  две коллекции обеспечивают:

\begin{itemize}
	\item Стандартизированную геометрию с размерами, нормализованными в диапазоне $[-0.5, 0.5]^3$, что устраняет артефакты масштабирования
	\item Водонепроницаемые меши (watertight), гарантирующие корректность расчёта SDF через алгоритм ray marching
	\item Низкую полигональную сложность (меньше $10^4$ треугольников на модель), позволяющую тестировать базовые свойства методов без перегрузки вычислительных ресурсов
\end{itemize}

\begin{enumerate}
	\item Базовый датасет: верификация функциональности
	\par
	В этом сравнении использовался более простой набор моделей, на которых методы, задействованные в сравнении, 
	не нарушались. Цель состояла в том, чтобы найти перспективный существующий метод, даже если его следует доработать для 
	устранения артефактов в целевых моделях.

	Для генерации SDF используются полигональные сетки из датасета. Это обеспечивает воспроизводимость экспериментов и 
	прямую сопоставимость метрик PSNR между методами.

	\item Стресс-тестовый датасет: анализ масштабируемости
	\par
	В качестве эталонного набора выбраны модели из ABC-Dataset, содержащий 1 млн CAD-моделей соответственно. Выбранные модели уже сложнее, поэтому 
	для на них тестировались не все методы, а только наиболее эффективные. Также некоторые варианты, например, имеют тонкие поверхности, что является серьезным 
	испытанием для SDF методов. 

	Таким образом, собранные модели проверяют методы на способность рендерить большие модели, обладающие сложной для SDF структурой.

\end{enumerate}

Использование двух комплементарных датасетов обеспечивает многоуровневую валидацию методов представления SDF, критически важную 
для оценки их практической применимости. Базовый датасет (напр., модели двигателей, скелетов) служит контролируемой средой 
для верификации корректности алгоритмов в идеализированных условиях, где метрики PSNR и время рендеринга отражают фундаментальные 
свойства методов без искажающего влияния шумов или артефактов. Это позволяет сравнить методы на стандартизированной базе, 
обеспечивая воспроизводимость результатов и прямую сопоставимость с предыдущими исследованиями.

Одновременно стресс-тестовый датасет выявляет пределы масштабируемости, демонстрируя, как методы ведут себя при обработке 
неводонепроницаемых мешей, моделей с >$10^8$ треугольников. Такая комбинация позволяет оценить устойчивость алгоритмов к реальным вызовам.

Синтез результатов двух датасетов формирует треугольник компромиссов "точность-производительность-память", 
позволяя выбрать оптимальный метод для конкретной задачи: нейронные методы для компактного представления стандартных 
объектов против гибридных сеток для промышленных CAD-моделей. Без многоуровневого тестирования сохраняется риск 
ложной оптимизации - улучшения метрик на синтетических данных при деградации на реальных сценах.

\begin{table}[h!]
	\centering
	\begin{tabular}{|l|c|}
			\hline
			\multicolumn{2}{|c|}{\textbf{Первый датасет}} \\
			\hline
			\textbf{Название модели} & \textbf{Размер, МБ} \\
			\hline
			Manifold     & 286.6 \\
			Bunny  & 10.37  \\
			Skeleton & 196.8 \\
			Roadbike & 163.3 \\
			Buddha     & 99.82 \\
			Crankcase & 141.0 \\
			Cylinder & 71.47 \\
			Stone & 124.0 \\
			Buggy & 634.6 \\
			Dragon & 72.76 \\
			Radiator & 371.4 \\
			WaterPump & 72.48 \\
			\hline
			\multicolumn{2}{c}{} \\[-1.5ex]
			\hline
			\multicolumn{2}{|c|}{\textbf{Второй датасет (выборка из ABC)}} \\
			\hline
			\textbf{Название подмножества} & \textbf{Размер, МБ} \\
			\hline
			ABC\_80006 & 154 \\
			ABC\_83870 & 199 \\
			ABC\_88060 & 84 \\
			ABC\_88828 & 20 \\
			ABC\_515447 & 58 \\
			ABC\_687231 & 108 \\
			ABC\_701584 & 45 \\
			ABC\_702109 & 122 \\
			bulldozer & 1511 \\
			DEMONSTRATOR & 591 \\
			\hline
	\end{tabular}
	\caption{Сравнение размеров моделей в двух датасетах}
	\label{tab:dataset_sizes}
\end{table}

\newpage

\section{Практическая реализация}

\subsection{Структура бенчмарка}

В ходе проделанной работы был создан бенчмарк, который способен сравнивать, как методы, которые пользователь может реализовать сам, так и готовые решения, 
предоставляемые в виде готовых проектов. Есть возможность переносить написанные методы на графический ускоритель, используя средства Kernel Slicer [ссылка] для генерации кода для 
API Vulkan из С++ кода. Для такой трансформации кода написанные методы должны удовлетворять определенным тредованиям этого инструмента. 

Сцена может рисоваться 
как в режиме Мультирендера [ссылка на LiteRT], который использует стандартную трассировку и шагаюшую трассировку лучей для поиска пересечения с поверхностью, так и рендер систему 
HydraCore3 [ссылка], разрабатываемую в лаборатории компьютерной графики и мультимедиа факультета ВМК МГУ, которая способна рендерить реалистичные сцены
за счет использования трассировки пути. На рисунке 1 показана схема работы бенчмарка.

\begin{figure}[h]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{bench_diag.jpg}}
  \caption{Схема реализация сравнений методов между собой}
  \label{fig:my_label}
\end{figure}

\newpage

\begin{figure}[h]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{xml_format.jpg}}
  \caption{Пример хранения информации о модели, её расположении и тд.}
  \label{fig:my_label}
\end{figure}

Работа бенчмарка идет в два этапа:
\begin{enumerate}
	\item Сборка каждым методом всех моделей с конкретными параметрами рендера. Полученные данные сохраняются в отдельные папки, откуда будут считываться во время рендера. Также записывается 
	время конвертации, размер и другие данные в специальный .csv файл.
	\item Во время рендера из каждой папки берутся данные и рендерятся. Результат сравнивается с референсным методом (по умолчанию это полигональная сетка) и сохраняется в .csv файл.
\end{enumerate}

\subsection{Контейнеризация}

Про докер

\subsection{Возникшие проблемы}

Во время написания программы возниклом множество проблем. Их можно разделить на 4 группы:

\begin{enumerate}
	\item Методы, имеющие открытую программную реализацию, часто не имели нужных входных параметров. Например, позиция камеры, позиция источника света. В некоторых методах 
	модель нормализуется в куб $[-1, 1]^3$, а не $[-0.5, 0.5]^3$, что давало неверную картинку. Аналогичную проблему вызывали разные настройки камеры, потому что 
	данные о ней могли по-разному храниться и использоваться. Учитывая, что изначально метод мог вообще не принимать на вход информацию о ней, то приходилось 
	это исправлять. Другой проблемой было освещение, потому что, например, в нескольких методах используется модель физического освещения, а в других 
	обходятся обычным рассчетом мест затенения, поэтому приходилось убирать такую сложную модель освещения и заменять на более простую, чтобы полученные картинки 
	совпадали по теням и цвету. 
	\item Возникла проблема организации хранения данных, потому что очень много параметров, которые меняют выходной результат. Таким образом, на первом этапе 
	бенчмарк сохраняет в отдельную папку бинарный файл с моделью и .xml файл, который используется для её дальнейшей загрузки в выбранную систему рендера. На втором этапе создается 
	другая папка, которая будет содержать отрендеренные изображения. На этом шаге сначала рисуется эталонный метод, чтобы другие реализации могли сразу с ним 
	сравниваться. Все полученные результаты метрик записываются в третью папку. Выбранный подход позволяет получить на каждом этапе простую иерархию данных.
	\item При добавлении метода "Массово-параллельный рендеринг сложных неявных поверхностей замкнутой формы" (MPR) пришлось решать проблему, связанную с тем, 
	что его было не с чем сравнивать, потому что он рендерит конструктивную сплошную геометрию, представленную в виде дерева, а не полигональной сеткой. Для этого метода пришлось 
	реализовывать свое синтаксическое дерево, которое уже могло использоваться, как функция дистанции. Следовательно, появился способ сравнивать SDF методы c 
	методами, реализующими конструктивную сплошную геометрию. Такой подход позволяет использовать бенчмарк для более широкого класса методов, которые изначально 
	могут не иметь возможность сравнения с уже добавленными вариантами.
	\item Ещё не маловажная задача - подбор параметров для каждого метода. Так как хотелось бы все модели получить примерно одинакового веса, чтобы методы могли 
	честно соревноваться в скорости рендера и качестве полученных картинок. Для выполнения этой задачи было решено первый датасет сжать до 2 Мб. Второй датасет сжимался в 10 раз.
\end{enumerate}

\newpage

\section{Эксперименты и результаты}

Поскольку различные методы имеют разные ограничения, было некорректно сравнивать их на моделях, 
на которых некоторые из методов просто не работали бы. Поэтому сначала выбирается упрощенный набор 
3D-моделей, которые удовлетворяют ограничениям для всех существующих методов, это сравнение по 
длинному списку. Затем выбирается подмножество наиболее эффективных методов и проводится сравнение 3D-моделей из 
набора данных ABC. Это сравнение по короткому списку: Instant NGP, NG LOG, N-BVH, LoD97.

\subsection{Пример конфигурационного файла}

\begin{verbatim}
{
backends:arr = { "CPU" }
renderers:arr = { "MR"}
render_modes:arr = { "LAMBERT_NO_TEX" }
models:arr = 
{ 
  "obj/ABC_80006.obj"
}
width:i = 1024
height:i = 1024
cameras:i = 4
iters:i = 1
spp:i = 4
output_folder:s = "results"
render_results_filename:s = "render"
build_results_filename:s = "build"
ref_type:s = "MESH"

repr_configs
{
	MESH 			 { default { 																																													} }
	INGP 			 { ingp 	  { iters:i = 8000 path:s = "../instant-ngp" 				} }
	SBS 			  { sbs 	   {depth:i = 8 brick_size:i = 3 brick_pad:i  = 0 } }
	OPENVDB		{ openvdb { w:i = 5 size:r = 0.01 																							} }
}
}

\end{verbatim}

\subsection{Длинный список}

Сравнение по длинному списку было выполнено во время работы над статьей по SCom дереву. В этом сравнении мы использовали более простой набор 
моделей, на которых методы, задействованные в сравнении, не нарушались (рис. 3). Цель состояла в том, чтобы найти перспективный существующий метод, 
даже если его следует доработать для устранения артефактов в целевых моделях.

\begin{figure}[h]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{img1.jpg}}
  \caption{}
  \label{fig:my_label}
\end{figure}

\newpage

\begin{figure}[h]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{img2.jpg}}
  \caption{Тестовые сцены для методов из длинного списка.}
  \label{fig:my_label}
\end{figure}

Выбранные методы:

\begin{itemize}
	\item Decimation [Garland and Heckbert 1997]
	\item RoLoPM [Chen et al. 2023]
	\item Micromesh [Maggiordomo et al. 2023]
	\item N-BVH [Weier et al. 2024]
	\item NGLOD [Takikawa et al. 2021]
	\item GVDB [Hoetzlein 2016]
	\item SBS [Herman et al. 2022]
	\item SDF Octree [Pujol and Chica 2023; Pujol and Chica 2024]
\end{itemize}

\newpage

\begin{figure}[h]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{table1.jpg}}
  \caption{Сравнение с другими методами на сценах из длинного списка. Параметры всех методов были 
	скорректированы для получения модели размером 2 Мб. Для моделей Buggy и Roadbike этого размера недостаточно 
	из-за большого количества деталей на них, что приводит к снижению PSNR. Рендеринг в разрешении 1400 × 1400 на 
	графическом процессоре Nvidia RTX 3070. \textbf{Средний PSNR = 40,8}.}
  \label{fig:my_label}
\end{figure}

\subsection{Короткий список}

Список методов:

\begin{itemize}
	\item Decimation [Garland and Heckbert 1997]
	\item Intant NGP (IMGP) [Müller et. al 2022]
	\item N-BVH [Weier et al. 2024]
	\item NGLOD [Takikawa et al. 2021]
	\item SBS [Herman et al. 2022]
\end{itemize}

\begin{table}[h]
	\centering
	\resizebox{\textwidth}{!}{ 
	\begin{tabular}{|c|cc|cc|cc|cc|cc|cc|cc|}
	\hline
	\multirow{2}{*}{Scene compressed in Mb} 
		& \multicolumn{2}{c|}{\textbf{INGP}} 
		& \multicolumn{2}{c|}{\textbf{MESH LOD}}
		& \multicolumn{2}{c|}{\textbf{NBVH}}
		& \multicolumn{2}{c|}{\textbf{NGLOD}}
		& \multicolumn{2}{c|}{\textbf{SDF SBS}} 
		& \multicolumn{2}{c|}{\textbf{Ours}} \\
	\cline{2-13}
	 & PSNR & t & PSNR & t & PSNR & t & PSNR & t & PSNR & t & PSNR & t \\
	\hline
	ABC\_80006 (15.4) & 24.4373 & 2.0208 & 20.8237 & 1.25595 & 30.0934 & 1.38029 & 32.9684 & 729.374 & 29.6357 & 1.39803 & \textbf{33.2679} & 1.39631 \\
	ABC\_83870 (19.9) & 21.9288 & 1.5898 & \textbf{33.4161} & 0.7658 & 27.4981 & 1.10991 & 27.1096 & 1217.91 & 27.6569 & 1.92584 & 30.7536 & 2.04484 \\
	ABC\_88060 (8.4) & 25.4127 & 1.6002 & 31.6253 & 0.94485 & 32.1536 & 3.56534 & 31.427 & 1187.38 & 33.7094 & 0.810781 & \textbf{36.724} & 1.08488 \\
	ABC\_88828 (2.0) & 25.3924 & 1.5706 & 21.2852 & 0.2608 & \textbf{30.956} & 3.84097 & 26.6941 & 953.696 & 22.4191 & 0.43615 & 22.7819 & 0.6985 \\
	ABC\_515447 (5.8) & 25.0376 & 1.54 & \textbf{37.2475} & 0.3861 & 29.8905 & 1.40661 & 29.2517 & 1093.44 & 26.0431 & 0.671531 & 32.6907 & 0.832969 \\
	ABC\_687231 (10.8) & 24.386 & 1.6312 & 26.6885 & 0.38195 & 29.5108 & 4.58807 & 28.7878 & 927.968 & 31.1062 & 1.63666 & \textbf{32.2423} & 1.60022 \\
	ABC\_701584 (4.5) & 23.4694 & 1.615 & 28.3015 & 0.3198 & 22.3917 & 0.903047 & 30.4694 & 995.088 & 29.347 & 0.428219 & \textbf{34.3476} & 1.28916 \\
	ABC\_702109 (12.2) & 24.2761 & 1.5688 & 22.9275 & 0.43865 & 31.0398 & 4.03193 & \textbf{31.4955} & 829.598 & 24.6758 & 0.956313 & 26.5279 & 1.26706 \\
	bulldozer (151.1) & - & - & - & - & - & - & - & - & 24.1367 & 1.39813 & \textbf{26.843} & 3.43475 \\
	DEMONSTRATOR (59.1) & 26.4516 & 1.6082 & - & - & \textbf{31.4977} & 0.810695 & 29.8707 & 828.228 & 24.5772 & 0.645969 & 28.1639 & 0.955281 \\
	\hline
	\end{tabular}
	}
	\caption{Сравнение с другими методами на наборе данных ABC из короткого списка, сжатом примерно в 10 раз. Рендеринг в разрешении 1024 × 1024 на графическом процессоре Nvidia RTX 4080.
	\textbf{Среднее PSNR = 29,9}.}
\end{table}

\newpage

\begin{figure}[H]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{img3.jpg}}
  \caption{Визуальное сравнение методов из короткого списка.}
  \label{fig:my_label}
\end{figure}

\begin{figure}[H]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{img4.jpg}}
  \caption{Визуальное сравнение методов из короткого списка в приближении.}
  \label{fig:my_label}
\end{figure}

\newpage

\begin{figure}[H]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{img5.jpg}}
  \caption{Визуальное сравнение методов из короткого списка в приближении.}
  \label{fig:my_label}
\end{figure}

\subsection{Вывод}

На основании результатов [Таблица 2, Рис 5, 6, 7, 8], полученных на наборе данных ABC, можно заметить, 
что CoMOctree демонстрирует высокое качество. Хотя он не достигает самых высоких показателей сжатия по сравнению со 
всеми другими подходами, он все же обеспечивает конкурентоспособную производительность, сохраняя мелкие детали, 
которые часто теряются при использовании альтернативных методов. Кроме того, наш метод способен обрабатывать самые большие 
и сложные модели, такие как бульдозер в наборе данных, которые большинство других методов не могут обработать.

Основываясь на визуальном сравнении можно сказать, что нейросетевые методы [ссылки] достаточно хорошо сжимают информацию о модели, однако не способны в должной мере 
отрисовать мелкие детали и, в целом, выглядят мыльно, шумно или имеют волнистую форму, что может свидетельствовать о том, что они хорошо запоминают границы объекта, но 
со временем перестают должным образом его улучшать, возможно, из-за низкой ошибки.

Алгоритмические методы [ссылки] хоть и не могут сравниться с нейросетями по сжатию, но способны дать более качественный результат, и они не падают на больших моделях. Также время рендера у таких 
подходов меньше, так как не надо перемножать кучу весов, чтобы найти значение растояния до поверхности в каждом пикселе. Существующая проблема тонких поверхностей, как 
видно на примере модели DEMONSTRATOR в полной мере не решается, тут нейросети в какой-то мере лучше, однако новый подход предложенный в CoMOctree позволяет эту 
проблему победить, в отличие от SBS[ссылка], Octree[ссылка] и тд.

\newpage

\subsection{Сравнение с MPR}

\begin{figure}[H]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{mpr.jpg}}
  \caption{Сравнение нашего метода с MPR. Сравнения слева основаны на памяти, а справа на времени рендеринга.}
  \label{fig:my_label}
\end{figure}

\begin{figure}[H]
  \centering
  \fbox{\includegraphics[width=1\linewidth]{mpr2.jpg}}
  \caption{Таблица со сравнениями из статьи [Bogolepov 2016] показывает, что предложенный может обрабатывать огромное количество примитивов, в то время как MPR не может [Рис. 9].}
  \label{fig:my_label}
\end{figure}

\section{Заключение}

В ходе работы были получены следующие результаты:

\begin{itemize}
	\item Проведен обзор существующих работ по представлениям функций дистанции со знаком.
	\item На основе выбранных методов был реализован бенчмарк, позволяющий сравнивать разные методы по нескольким метрикам, при желании можно без проблем добавить новые варианты сравнения.
	\item Полученная программа при необходимости способна переводить код с С++ на графический процессор с целью ускорения выполнения вычислений.
	\item Подготовлен ряд сцен для демонстрации достоинств и недостатков каждого из методов.
	\item Проведено сравнение выбранных методов, замерены такие показатели, как время рендера, размер модели, качество полученных изображений. 
\end{itemize}

\newpage

\section{Список литературы}

\end{document}
